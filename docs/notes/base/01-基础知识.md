## 优化前言
性能优化是把双刃剑，有好的一面也有坏的一面。好的一面就是能提升网站性能，坏的一面就是配置麻烦，或者要遵守的规则太多。并且某些性能优化规则并不适用所有场景，需要谨慎使用


## if-else 对比 switch
> 使用if else 还是 switch 目前一般是从代码可读性的角度出发，基于判断条件的数量来决定：数量越多就越倾向于 switch 而不是 if else。

事实证明除了代码可读性，switch 的运行速度是比 if else 更快的。


```javascript
if (color == 'blue') {

} else if (color == 'yellow') {

} else if (color == 'white') {

} else if (color == 'black') {

} else if (color == 'green') {

} else if (color == 'orange') {

} else if (color == 'pink') {

}

switch (color) {
    case 'blue':

        break
    case 'yellow':

        break
    case 'white':

        break
    case 'black':

        break
    case 'green':

        break
    case 'orange':

        break
    case 'pink':

        break
}

```
像上面的这种情况，从可读性来说，使用 `switch` 是比较好的（js 的 switch 语句不是基于哈希实现，而是循环判断，所以说 if-else、switch 从性能上来说是一样的）。

## 查找表

> 当条件语句特别多时，使用 `switch` 和 `if-else` 不是最佳的选择，这时不妨试一下查找表。查找表（`lookup Tables`）可以使用数组和对象来构建。

例一：
```javascript
// 通过条件判断
function getColor(c) {
    if(c == 'blue'){
        return 'blue的rgba值'
    }else if(c === 'block'){
        return 'block的rgba值'
    }else if(c === 'yellow'){
        return 'yellow的rgba值'
    }else(c === 'green'){
        return 'green的rgba值'
    }
}

// 通过 map 映射
function getColor(c) {
    return {
        'blue': 'blue的rgba值',
        'block': 'block的rgba值',
        'yellow': 'yellow的rgba值',
        'green': 'green的rgba值',
    }[c]
}

```

例二：
```javascript
switch (index) {
    case '0':
        return result0
    case '1':
        return result1
    case '2':
        return result2
    case '3':
        return result3
    case '4':
        return result4
    case '5':
        return result5
    case '6':
        return result6
    case '7':
        return result7
    case '8':
        return result8
}

```

可以将这个 `switch` 语句转换为查找表

```javascript
const results = [result0,result1,result2,result3,result4,result5,result6,result7,result8]

return results[index]
```

如果条件语句不是数值而是字符串，可以用对象来建立查找表

```javascript
const map = {
  red: result0,
  green: result1,
}

return map[color]
```
## v-if 和 v-show 区分使用场景


**v-if** 是 **真正** 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

**v-show** 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。

所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。

## v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

（1）v-for 遍历必须为 item 添加 key

在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。

（2）v-for 遍历避免同时使用 v-if

v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。

推荐：

```vue
<ul>
  <li
    v-for="user in activeUsers"
    :key="user.id">
    {{ user.name }}
  </li>
</ul>
computed: {
  activeUsers: function () {
    return this.users.filter(function (user) {
	 return user.isActive
    })
  }
}
```

不推荐：
```vue
<ul>
  <li
    v-for="user in users"
    v-if="user.isActive"
    :key="user.id">
    {{ user.name }}
  </li>
</ul>
```

## 长列表性能优化
Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

```javascript
export default {
  data: () => ({
    users: {}
  }),
  async created() {
    const users = await axios.get("/api/users");
    this.users = Object.freeze(users);
  }
};
```

## 事件的销毁
Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：
```javascript
created() {
  addEventListener('click', this.click, false)
},
beforeDestroy() {
  removeEventListener('click', this.click, false)
}
```

## 提取公共代码
如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：

相同的资源被重复加载，浪费用户的流量和服务器的成本。
每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。

所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：

```javascript
// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。
new webpack.optimize.CommonsChunkPlugin({
  name: 'vendor',
  minChunks: function(module, count) {
    return (
      module.resource &&
      /\.js$/.test(module.resource) &&
      module.resource.indexOf(
        path.join(__dirname, '../node_modules')
      ) === 0
    );
  }
}),
// 抽取出代码模块的映射关系
new webpack.optimize.CommonsChunkPlugin({
  name: 'manifest',
  chunks: ['vendor']
})
```
### NVM管理Node版本

> 先安装一个 nvm（ https://github.com/creationix/nvm ）

```bash
$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.2/install.sh | bash
```

nvm 的全称是 **Node Version Manager**，之所以需要这个工具，是因为 Node.js 的各种特性都没有稳定下来，所以我们经常由于老项目或尝新的原因，需要切换各种版本。

安装完成后，你的 shell 里面应该就有个 nvm 命令了，调用它试试

```
$ nvm
```

当看到有输出时，则 nvm 安装成功。

**安装 Node.js**

使用 nvm 的命令安装 Node.js 

```
$ nvm install 0.12
```

安装完成后，查看一下

```
$ nvm ls
```

这时候可以看到自己安装的所有 Node.js 版本，输出应如下：

![](https://raw.githubusercontent.com/alsotang/node-lessons/master/lesson0/1.png)

（图1）

那个绿色小箭头的意思就是现在正在使用的版本，我这里是 `v0.10.29`。我还安装了 `v0.11.14`，但它并非我当前使用的版本。

如果你那里没有出现绿色小箭头的话，告诉 nvm 你要使用 `0.12.x` 版本

```
$ nvm use 0.12
```

然后再次查看，这时候小箭头应该出现了。

OK，我们在终端中输入

```
$ node
```

REPL(read–eval–print loop) 应该就出来了，那我们就成功了。

随便敲两行命令玩玩吧。

比如 `> while (true) {}`，这时你的 CPU 应该会飚高。

**完善安装**

上述过程完成后，有时会出现，当开启一个新的 shell 窗口时，找不到 node 命令的情况。

这种情况一般来自两个原因

1. shell 不知道 nvm 的存在

2. nvm 已经存在，但是没有 default 的 Node.js 版本可用。

**解决方式：**

一、检查 `~/.profile` 或者 `~/.bash_profile` 中有没有这样两句

```
export NVM_DIR="/Users/YOURUSERNAME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && . "$NVM_DIR/nvm.sh"  # This loads nvm
```

没有的话，加进去。这两句会在 bash 启动的时候被调用，然后注册 nvm 命令。

二、调用 `$ nvm ls`

看看像不像上述图1中一样，有 default 的指向。

如果没有的话，执行 `$ nvm alias default 0.12`再`$ nvm ls`


## Node.js 模块
模块系统是 Node.js 最基本也是最常用的。一般情况模块可分为四类：
- 原生模块
- 文件模块
- 第三方模块
- 自定义模块

### 自定义模块

1. 创建模块(b.js)

```javascript
//b.js
function FunA(){
    return 'Tom';
}
//暴露方法 FunA
module.exports = FunA;
```

2. 加载模块(a.js)

```javascript
//a.js
var FunA = require('./b.js');//得到 b.js => FunA
var name = FunA();// 运行 FunA，name = 'Tom'
console.log(name); // 输出结果
```

### module.exports

module.exports 就 Node.js 用于对外暴露，或者说对外开放指定访问权限的一个对象。如上面的案例，如果没有这段代码

```javascript
module.exports = FunA;
```

那么 `require('./b.js')` 就会为 `undefined`。
一个模块中有且仅有一个 `module.exports`，如果有多个那后面的则会覆盖前面的。

### exports

> `exports` 是 `module` 对象的一个属性，同时它也是一个对象。在很多时候一个 js 文件有多个需要暴露的方法或是对象，`module.exports` 又只能暴露一个，那这个时候就要用到 `exports`:

```javascript
function FunA(){
    return 'Tom';
}

function FunB(){
    return 'Sam';
}

exports.FunA = FunA;
exports.FunB = FunB;
```

```javascript
//FunA = exports,exports 是一个对象
var FunA = require('./b.js');
var name1 = FunA.FunA();// 运行 FunA，name = 'Tom'
var name2 = FunA.FunB();// 运行 FunB，name = 'Sam'
console.log(name1);
console.log(name2);
```

当然在引入的时候也可以这样写

```javascript
//FunA = exports,exports 是一个对象
var {FunA, FunB} = require('./b.js');
var name1 = FunA();// 运行 FunA，name = 'Tom'
var name2 = FunB();// 运行 FunB，name = 'Sam'
console.log(name1);
console.log(name2);
```

## npm scripts

### NPM版本管理

```
npm -v
```

**使用nrm管理npm版本**

```
npm install -g nrm
```

> 执行命令`nrm ls`查看可选的源。


```
*npm ---- https://registry.npmjs.org/

cnpm --- http://r.cnpmjs.org/

taobao - http://registry.npm.taobao.org/

eu ----- http://registry.npmjs.eu/

au ----- http://registry.npmjs.org.au/

sl ----- http://npm.strongloop.com/

nj ----- https://registry.nodejitsu.com/
```

其中，带`*`的是当前使用的源，上面的输出表明当前源是官方源。

1. 切换

如果要切换到`taobao`源，执行命令 `nrm use taobao`。

2. 增加

你可以增加定制的源，特别适用于添加企业内部的私有源，执行命令 `nrm add <registry> <url>`，其中`reigstry`为源名，`url`为源的路径。

```
nrm add registry http://registry.npm.frp.trmap.cn/
```

3. 删除

执行命令`nrm del <registry>`删除对应的源。

4. 测试速度

你还可以通过 `nrm test` 测试相应源的响应时间。

```
nrm test npm             
```

### 什么是 npm 脚本

> npm 允许在`package.json`文件里面，使用`scripts`字段定义脚本命令。`package.json` 里面的`scripts` 字段是一个对象。它的每一个属性，对应一段脚本。定义在`package.json`里面的脚本，就称为 `npm` 脚本。

查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的`npm run`命令。

### 使用

- `npm run` 脚本名称
- 如果是并行执行（即同时的平行执行），可以使用&符号。
`npm run script1.js & npm run script2.js`
- 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号。`npm run script1.js && npm run script2.js`

### 简写形式

- `npm start` 即 `npm run start`
- `npm stop` 即 `npm run stop`
- `npm test` 即 `npm run test`
- `npm restart` 即 `npm run stop && npm run restart && npm run start`
